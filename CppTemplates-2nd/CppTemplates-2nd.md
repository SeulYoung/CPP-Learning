# C++ Templates - The Complete Guide 2nd Edition

> **Note**
> 感谢 [xiaoweiChen](https://github.com/xiaoweiChen) 的翻译

## 第1章 函数模板

### 1.1 初识函数模板

- 模板“编译”分为两个阶段:
  - 若在定义时不进行实例化，则会检查模板代码的正确性，而忽略模板参数，这包括:
    - 语法错误，比如: 缺少分号
    - 使用未知名称的模板参数 (类型名、函数名……)
    - 检查 (不依赖于模板参数) 静态断言
  - 实例化时，再次检查模板代码，确保生成的代码有效，特别是所有依赖于模板参数的部分，都会进行重复检查

### 1.5 重载函数模板

- 非模板函数可以与相同名称和相同类型的函数模板共存，其他相同的情况下，重载解析将优先使用非模板方式
  - 但是若模板可以生成匹配更好的函数实例，则选择模板
  - 也可以显式指定一个空的模板参数列表，这种语法表明只有模板才能解析调用，但所有模板参数都应该根据调用参数进行推导
  - 对推导的模板参数不会进行自动类型转换，但是会自动的对普通函数参数进行类型转换，因此此时调用会使用非模板函数

- 重载函数模板时，最好不要进行不必要的更改，可以将更改限制在参数的数量或显式地指定模板参数，
  - 否则，可能会出现意想不到的后果，示例如下

    ```C++
    1 #include <cstring>
    2
    3 // 任意类型的两个最大值(引用调用)
    4 template<typename T>
    5 T const& max (T const& a, T const& b)
    6 {
    7 return b < a ? a : b;
    8 }
    9
    10 // 最多两个C字符串(值调用)
    11 char const* max (char const* a, char const* b)
    12 {
    13 return std::strcmp(b,a) < 0 ? a : b;
    14 }
    15
    16 // 任何类型的最多三个值(引用调用)
    17 template<typename T>
    18 T const& max (T const& a, T const& b, T const& c)
    19 {
    20 return max (max(a,b), c); // 如果max(a,b)使用了按值调用就会出错
    21 }
    22
    23 int main ()
    24 {
    25 auto m1 = ::max(7, 42, 68); // OK
    26
    27 char const* s1 = "frederic";
    28 char const* s2 = "anica";
    29 char const* s3 = "lucas";
    30 auto m2 = ::max(s1, s2, s3); // 运行时错误（未定义的行为），因为对于 C 字符，max(a,b) 创建了一个新临时变量，并通过引用返回
    31 }
    ```

### 1.6 常见问题

- 使用值，还是引用传递参数?
  - 为什么通常声明函数按值传递参数，而不是使用引用。一般来说，除了简单类型 (比如基本类型或 std::string_view)，因为不会创建副本，所以推荐使用引用传递
  - 然而，按值传递在下面的情况下会更好:
    - 语法简单
    - 编译器会进行很好的优化
    - 移动语义会使复制成本降低
    - 没有复制或移动操作
  - 此外，对于模板来说:
    - 模板可能同时用于简单类型和复杂类型，因此为复杂类型选择这种方法时，可能会对简单类型产生反效果
    - 作为调用者，可以通过引用来传递参数，可以使用 std::ref() 和 std::cref()
    - 虽然传递字符串字面值或原始数组可能会产生问题，但通过引用传递通常会有更多的问题
  - 这些将在第 7 章中详细讨论，目前，我们使用值传递参数 (除非某些功能只有在使用引用时才使用引用)

- 为什么不用内联?
  - 通常，函数模板不必使用内联声明，与普通的非内联函数不同，我们可以在头文件中定义非内联函数模板，并在多个翻译单元中包含该头文件
  -该规则的唯一例外是，对特定类型的模板进行完全特化，从而产生的代码不再是泛型 (定义了所有模板参数)

- 为什么不用 constexpr?
  - C++11 后，可以使用 constexpr 提供在编译时计算某些值的能力，对于很多模板来说，这很有意义
  - 第 8.2 节将讨论使用 constexpr 的例子，但是为了让我们的注意力集中在基本特性上，在讨论其他模板特性时，我们通常会跳过 constexpr

## 第2章 类模板

### 2.2 使用栈类模板

- 对于类模板，只有在使用成员函数时才实例化，这节省了时间和空间，并且只允许使用部分地类模板
  - 如果类模板具有静态成员，则对于使用类模板的每个类型实例，这些成员也会实例化一次


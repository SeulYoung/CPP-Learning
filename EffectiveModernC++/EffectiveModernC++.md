# Effective Modern C++

## Deducing Types

### 1. Understand template type deduction

- 以如下模板为例，T的类型推导不仅取决于expr的类型，也取决于ParamType的类型，这里有三种情况

  ```C++
  template<typename T>
  void f(ParamType param);

  f(expr); // 从expr中推导T和ParamType
  ```

  - ParamType是一个指针或引用，但不是通用引用，即`T& param`（关于通用引用请参见条款24。在这里你只需要知道它存在，而且不同于左值引用和右值引用）
    - 在这种情况下，如果expr的类型是一个引用，忽略引用部分，然后expr的类型与ParamType进行模式匹配来决定T
  - ParamType是一个通用引用，即`T&& param`
    - 如果expr是左值，T和ParamType都会被推导为左值引用。这非常不寻常，第一，这是模板类型推导中唯一一种T被推导为引用的情况。第二，虽然ParamType被声明为右值引用类型，但是最后推导的结果是左值引用。
    - 如果expr是右值，就使用正常的（也就是情景一）推导规则
  - ParamType既不是指针也不是引用，即`T param`
    - 当ParamType既不是指针也不是引用时，通过传值（pass-by-value）的方式处理，和之前一样，如果expr的类型是一个引用，忽略这个引用部分
    - 如果忽略expr的引用性（reference-ness）之后，expr是一个const，那就再忽略const。如果它是volatile，也忽略volatile（volatile对象不常见，它通常用于驱动程序的开发中。关于volatile的细节请参见条款40）
    - 但是此处有一个特殊情况，考虑`const char* const ptr = "Hello"`，此时ParamType被推导为`const char*`
      - 这种情况，ptr自身的值会被传给形参，根据类型推导的第三条规则，ptr自身的常量性constness将会被省略，所以param是`const char*`，也就是一个可变指针指向const字符串。在类型推导中，这个指针指向的数据的常量性constness将会被保留，但是当拷贝ptr来创造一个新指针param时，ptr自身的常量性constness将会被忽略。

- 另一个需要注意的问题是数组实参的类型推导，虽然数组和指针有时可以互换，但是两者并不相同
  - 对于`T param`，因为数组形参会视作指针形参，所以T被推导为指针，而不是数组
  - 但是对于`T& param`，虽然函数不能声明形参为真正的数组，但是可以接受指向数组的引用，例如对于`const char name[] = "J. P. Briggs";`，T被推导为`const char[13]`，形参（对这个数组的引用）的类型则为`const char (&)[13]`

- 最后一个细节是函数实参，不只是数组会退化为指针，函数类型也会退化为一个函数指针，我们对于数组类型推导的全部讨论都可以应用到函数类型推导和退化为函数指针上来
  - 指向函数的指针和指向函数的引用，实际上没有什么不同，但是如果你知道数组退化为指针，你也会知道函数退化为指针。

### 2. Understand auto type deduction

- auto类型推导通常和模板类型推导相同，但是auto类型推导假定`{}`初始化代表`std::initializer_list`，而模板类型推导不这样做

- 在C++14中auto允许出现在函数返回值或者lambda函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是auto类型推导

### 3. Understand decltype

- 通常，decltype会精确的告诉你你想要的结果，相比模板类型推导和auto类型推导，decltype只是简单的返回名字或者表达式的类型
  - decltype最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型

- 但是对于T类型的不是单纯的变量名的**左值表达式**，decltype总是产出T的引用（`T&`），当使用`decltype(auto)`的时候一定要加倍的小心，在表达式中看起来无足轻重的细节将会影响到推导结果

  ```C++
  decltype(auto) f2()
  {
      int x = 0;
      return (x); //return表达式，decltype((x))是int&，所以f2返回int&
  }
  ```

### 4. Know how to view deduced types

- 类型推断可以从IDE看出，从编译器报错看出，从Boost TypeIndex库的使用看出

- 这些工具可能既不准确也无帮助，所以理解C++类型推导规则才是最重要的

## auto

### 5. Prefer auto to explicit type declarations

- auto变量从初始化表达式中推导出类型，所以变量必须初始化

- 通常使用`std::function`存放lambda表达式产生的可调用对象时，auto是更好的选择
  - auto避免了语法冗长，切不需要重复写很多形参类型，auto声明的变量保存一个和闭包一样类型的（新）闭包，因此使用了与闭包相同大小存储空间
  - 但实例化`std::function`并声明对象将会有固定的大小，这个大小可能不足以存储一个闭包，这个时候`std::function`的构造函数将会在堆上面分配内存来存储，这就造成了使用`std::function`比auto声明变量会消耗更多的内存，并且通过具体实现我们得知通过`std::function`调用一个闭包几乎无疑比auto声明的对象调用要慢
  - 换句话说，`std::function`方法比auto方法要更耗空间且更慢，还可能有out-of-memory异常。并且比起写`std::function`实例化的类型来，使用auto要方便得多，在这场存储闭包的比赛中，auto无疑取得了胜利
  - C++14中甚至可以把lambda形参也使用auto

  ```C++
  auto derefLess =                                //C++14版本
    [](const auto& p1,                          //被任何像指针一样的东西
       const auto& p2)                          //指向的值的比较函数
    { return *p1 < *p2; };
  ```

- 通常auto还可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。

### 6. Use the explicitly typed initializer idiom when auto deduces undesired types

- 作为一个通则，不可见的代理类通常不适用于auto，这样类型的对象的生命期通常不会设计为能活过一条语句，所以创建那样的对象你基本上就走向了违反程序库设计基本假设的道路
  - “Proxy”设计模式是软件设计这座万神庙中一直都存在的高级会员，一些典型的可见代理类如`std::shared_ptr`和`std::unique_ptr`，而典型的不可见代理类如`std::vector<bool>::reference`和`std::bitset::reference`

- 解决方案是强制使用一个不同的类型推导形式，这种方法我通常称之为显式类型初始器惯用法（the explicitly typed initialized idiom）
  - 显式类型初始器惯用法使用auto声明一个变量，然后对表达式强制类型转换（cast）得出你期望的推导结果，例如`auto x = static_cast<bool>(y);`

## Moving to Modern C++

### 7. Distinguish () and {} when creating objects

- `{}`语法最广泛使用的初始化语法，能用于各种不同的上下文，它防止了隐式的变窄转换，而且对于C++最令人头疼的解析也天生免疫
  - 令人头疼的解析是指，C++规定任何可以被解析为一个声明的东西必须被解析为声明，这个规则的副作用使你可能想创建一个使用默认构造函数构造的对象，却不小心变成了函数声明

- 但是问题在于，在构造函数重载决议中，编译器会尽最大努力将`{}`初始化与`std::initializer_list`参数匹配，即便其他构造函数看起来是更好的选择
  - 例如对于数值类型的`std::vector`来说使用花括号初始化和圆括号初始化会造成巨大的不同
  - 而且在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战

### 8. Prefer nullptr to 0 and NULL

- 优先考虑nullptr而非0和NULL
  - 使用nullptr代替0和NULL可以避开那些令人奇怪的函数重载决议（因为它们实际类型都是整型），也可以使代码表意明确
  - 使用nullptr，模板不会有什么特殊的转换，模板类型推导将0和NULL推导为一个错误的类型（即它们的实际类型，而不是作为空指针的隐含意义）

### 9. Prefer alias declarations to typedefs

- 优先使用别名声明而非typedef
  - typedef不支持模板化，但是别名声明支持。
  - 别名模板避免了使用“::type”后缀，而且在模板中使用typedef还需要在前面加上typename
  - C++14提供了C++11所有type traits转换的别名声明版本

### 10. Prefer scoped enums to unscoped enums

- 优先考虑限域enum（由于是通过`enum class`声明，所以也会被称为枚举类）而非未限域enum
  - 限域enum的枚举名仅在enum内可见，要转换为其它类型只能使用cast
  - 非限域/限域enum都支持底层类型说明语法，限域enum底层类型默认是int，非限域enum没有默认底层类型
  - 限域enum总是可以前置声明，非限域enum仅当指定它们的底层类型时才能前置声明

### 11. Prefer deleted functions to private undefined ones

- `= delete`和声明为私有成员可能看起来只是方式不同，别无其他区别，其实还有一些实质性意义差别的
  - deleted函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用deleted函数也不能通过编译
  - deleted函数被声明为public而不是private，是因为当客户端代码试图调用成员函数时，C++会在检查deleted状态前检查它的访问性，当调用一个私有的deleted函数，一些编译器只会给出该函数是private的错误
  - deleted函数还有一个重要的优势是任何函数都可以标记为deleted，而只有成员函数可被标记为private
    - 例如创建deleted重载函数，其参数就是我们想要过滤的类型，从而避免隐式类型转换的无意义调用
    - 另一个deleted函数用武之地是禁止一些模板的实例化，例如要求一个模板仅支持原生指针，则需要使用delete关键字标注`void*`（特殊情况，因为没办法对它们进行解引用，或者加加减减等）和`char*`（特殊情况，因为它们通常代表C风格的字符串，而不是正常意义下指向单个字符的指针）相关的模板实例

### 12. Declare overriding functions override

- C++11引入了两个上下文关键字（contextual keywords），`override`和`final`（向虚函数添加final可以防止派生类重写。final也能用于类，这时这个类不能用作基类），这两个关键字的特点是它们是保留的，它们只是位于特定上下文才被视为关键字

- C++11之后要想重写一个函数，必须满足下列全部需求，这么多的重写需求意味着哪怕一个小小的错误也会造成巨大的不同，所以最好使用override关键字来声明重写函数
  - 基类函数必须是virtual
  - 基类和派生类函数名必须完全一样（除非是析构函数）
  - 基类和派生类函数形参类型必须完全一样
  - 基类和派生类函数常量性constness必须完全一样
  - 基类和派生类函数的返回值和异常说明（exception specifications）必须兼容
  - 函数的引用限定符（reference qualifiers）必须完全一样，成员函数的引用限定符是C++11很少抛头露脸的特性，它可以限定成员函数只能用于左值或者右值。成员函数不需要virtual也能使用

    ```C++
    class Widget {
    public:
      using DataType = std::vector<double>;
      …
      DataType& data() &              //对于左值Widgets,
      { return values; }              //返回左值引用
      
      DataType data() &&              //对于右值Widgets,
      { return std::move(values); }   //返回右值（临时对象）
      …

    private:
      DataType values;
    };
    ```

### 13. Prefer const_iterators to iterators

- 优先考虑`const_iterator`而非`iterator`
  - 在最大程度通用的代码中，优先考虑非成员函数版本的begin，end，rbegin等，而非同名成员函数

### 14. Declare functions noexcept if they won't emit exceptions

- noexcept是函数接口的一部分，这意味着调用者可能会依赖它，noexcept可以影响到调用代码的异常安全性（exception safety）和效率，就其本身而言，函数是否为noexcept和成员函数是否const一样重要
  - 在一个noexcept函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈（the runtime stack）处于可展开状态，也不需要保证当异常离开noexcept函数时，noexcept函数中的对象按照构造的反序析构，因此noexcept函数比non-noexcept函数更容易优化

- noexcept对于移动语义，swap，内存释放函数和析构函数非常有用，只要可能就应该将它们实现为noexcept
  - 例如在C++11中，`std::vector`在进行扩容时，一个很自然的优化就是将元素的复制操作替换为移动操作
    - 但是很不幸运，这会破坏push_back的异常安全保证，如果n个元素已经从老内存移动到了新内存区，但异常在移动第n+1个元素时抛出，那么push_back操作就不能完成
    - 但是原始的`std::vector`已经被修改：有n个元素已经移动走了，恢复std::vector至原始状态也不太可能，因为从新内存移动到老内存本身又可能引发异常
    - 这是个很严重的问题，因为老代码可能依赖于push_back提供的强烈的异常安全保证，因此C++11版本的实现不能简单的将push_back里面的复制操作替换为移动操作，除非知晓移动操作绝不抛异常，这时复制替换为移动就是安全的
  - 默认情况下，内存释放函数和析构函数（不管是用户定义的还是编译器生成的）都是隐式noexcept的，因此它们不需要声明noexcept
    - 析构函数非隐式noexcept的情况仅当类的数据成员（包括继承的成员还有继承成员内的数据成员）明确声明它的析构函数可能抛出异常（如声明`noexcept(false)`）
    - 这种析构函数不常见，标准库里面没有，如果一个对象的析构函数可能被标准库使用（比如在容器内或者被传给一个算法），析构函数又可能抛异常，那么程序的行为是未定义的

- 大多数函数是异常中立的，而不是noexcept，这些函数自己不抛异常，但是它们内部的调用可能抛出
  - 此时，异常中立函数允许那些抛出异常的函数在调用链上更进一步直到遇到异常处理程序，而不是就地终止
  - 异常中立函数绝不应该声明为noexcept，因为它们可能抛出那种“让它们过吧”的异常，因此大多数函数缺少noexcept设计

### 15. Use constexpr whenever possible

- constexpr对象是const，它被在编译期可知的值初始化
  - 编译期可知的值“享有特权”，它们可能被存放到只读存储空间中，对于那些嵌入式系统的开发者，这个特性是相当重要的
  - 更广泛的应用是“其值编译期可知”的常量整数会出现在需要“整型常量表达式（integral constant expression）的上下文中，这类上下文包括数组大小，整数模板参数（包括`std::array`对象的长度），枚举名的值，对齐修饰符（`alignas(val)`），等等
  - 简而言之，所有constexpr对象都是const，但不是所有const对象都是constexpr

- 涉及到constexpr函数时，constexpr对象的使用情况就更有趣了，当传递编译期可知的值时，constexpr函数可以产出编译期可知的结果
  - constexpr函数可以用于需求编译期常量的上下文，如果你传给constexpr函数的实参在编译期可知，那么结果将在编译期计算，如果实参的值在编译期不知道，你的代码就会被拒绝
  - 当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果，这意味着你不需要两个函数，一个用于编译期计算，一个用于运行时计算，constexpr全做了

- 本条款的建议是尽可能的使用constexpr，因为constexpr对象和constexpr函数可以使用的范围比non-constexpr对象和函数大得多，使用constexpr关键字可以最大化你的对象和函数可以使用的场景，但是要注意的是constexpr是对象和函数接口的一部分

### 16. Make const member functions thread safe

- 确保const成员函数线程安全，除非你确定它们永远不会在并发上下文（concurrent context）中使用
  - 使用`std::atomic`变量可能比互斥量（`std::mutex`）提供更好的性能，但是它只适合操作单个变量或内存位置

### 17. Understand special member function generation

- 在C++术语中，特殊成员函数是指C++自己生成的函数

- C++98有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符
  - 当然在这里有些细则要注意，这些函数仅在需要的时候才生成，比如某个代码使用它们但是它们没有在类中明确声明
  - 默认构造函数仅在类完全没有构造函数的时候才生成（防止编译器为某个类生成构造函数，但是你希望那个构造函数有参数）
  - 生成的特殊成员函数是隐式public且inline，它们是非虚的，除非相关函数是在派生类中的析构函数，派生类继承了有虚析构函数的基类，在这种情况下，编译器为派生类生成的析构函数是虚的
  - C++11析构函数一个稍微不同的是现在析构默认noexcept

- C++11特殊成员函数俱乐部迎来了两位新会员：移动构造函数和移动赋值运算符
  - 移动操作仅在需要的时候生成，如果生成了，就会对类的non-static数据成员执行逐成员的移动，那意味着移动构造函数根据参数里面对应的成员移动构造出新的non-static部分，移动赋值运算符根据参数里面对应的non-static成员移动赋值
    - 移动构造函数也移动构造基类部分（如果有的话），移动赋值运算符也是移动赋值基类部分
    - 对一个数据成员或者基类使用移动构造或者移动赋值时，没有任何保证移动一定会真的发生，逐成员移动，实际上，更像是逐成员移动请求，因为对不可移动类型（即对移动操作没有特殊支持的类型，比如大部分C++98传统类）使用移动操作实际上执行的是拷贝操作
    - 逐成员移动的核心是对对象使用`std::move`，然后函数决议时会选择执行移动还是拷贝操作，可以简单记住如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作

- 由于C++11移动操作带来的变动，需要额外讨论移动操作生成的精确条件，以及对拷贝操作的影响
  - 众所周知，两个拷贝操作是独立的，声明一个不会限制编译器生成另一个，但是两个移动操作却不是相互独立的，如果你声明了其中一个，编译器就不再生成另一个
  - 因为如果给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别
    - 如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题，所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数
  - 再进一步，如果一个类显式声明了拷贝操作，编译器就不会生成移动操作
    - 这种限制的解释是如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适
  - 再思考另一个方向，声明移动操作（构造或赋值）使得编译器禁用拷贝操作
    - 编译器通过给拷贝操作加上delete来保证，毕竟，如果逐成员移动对该类来说不合适，也没有理由指望逐成员拷贝操作是合适的，但是注意，禁用的是自动生成的拷贝操作，对于用户声明的拷贝操作不受影响
  - 还有一个需要讨论的是“Rule of Three”规则，此规则带来的后果就是只要出现用户定义的析构函数就意味着简单的逐成员拷贝操作不适用于该类
    - 那意味着如果一个类声明了析构，拷贝操作可能不应该自动生成，因为它们做的事情可能是错误的，所以有时C++11抛弃了已声明拷贝操作或析构函数的类的拷贝操作的自动生成
    - 这意味着如果你的某个声明了析构或者拷贝的类依赖自动生成的拷贝操作，你应该考虑升级这些类，消除依赖
      - 假设编译器生成的函数行为是正确的（即逐成员拷贝类non-static数据是你期望的行为），你的工作很简单，C++11的`= default`就可以表达你想做的
    - 好的，我知道你可能会问，到底什么是“Rule of Three”规则
      - 这个规则的概括便是如果声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个
      - 它来源于长期的观察，即用户接管拷贝操作的需求几乎都是因为该类会做其他资源的管理，这也几乎意味着：
        - 无论哪种资源管理如果在一个拷贝操作内完成，也应该在另一个拷贝操作内完成
        - 类的析构函数也需要参与资源的管理（通常是释放）。通常要管理的资源是内存
      - 这也是为什么标准库里面那些管理内存的类（如会动态内存管理的STL容器）都声明了拷贝构造，拷贝赋值和析构

- 总结C++11对于特殊成员函数处理的规则如下：
  - 默认构造函数：和C++98规则相同，仅当类不存在用户声明的构造函数时才自动生成
  - 析构函数：基本上和C++98相同，稍微不同的是现在析构默认noexcept，和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数
  - 拷贝构造函数：和C++98运行时行为一样，逐成员拷贝non-static数据，仅当类没有用户定义的拷贝构造时才生成，如果类声明了移动操作它就是delete的，当用户声明了拷贝赋值或者析构，该函数的自动生成已被废弃
  - 拷贝赋值运算符：和C++98运行时行为一样，逐成员拷贝赋值non-static数据，仅当类没有用户定义的拷贝赋值时才生成，如果类声明了移动操作它就是delete的，当用户声明了拷贝构造或者析构，该函数的自动生成已被废弃
  - 移动构造函数和移动赋值运算符：都对非static数据执行逐成员移动，仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成

- 另一个注意点是没有“成员函数模版阻止编译器生成特殊成员函数”的规则，这意味着此时编译器仍会生成移动和拷贝操作（假设正常生成它们的条件满足），即使可以模板实例化产出拷贝构造和拷贝赋值运算符的函数签名

## Smart Pointers

### 18. Use std::unique_ptr for exclusive-ownership resource management

- `std::unique_ptr`是轻量级、快速的、只可移动（move-only）的管理专有所有权语义资源的智能指针
  - 默认情况，资源销毁通过delete实现，但是支持自定义删除器，有状态的删除器和函数指针会增加`std::unique_ptr`对象的大小
    - 无状态函数（stateless function）对象（比如不捕获变量的lambda表达式）对大小没有影响，这意味当自定义删除器可以实现为函数或者lambda时，尽量使用lambda
    - 无状态函数对象的大小为1，但是可以通过EBCO（Empty Base Class Optimisation）优化使其不占用空间
    - 所谓EBCO，在C++20之前通过继承空类来实现空间优化，C++20之后可以通过`[no_unique_address]`来让编译器检查空类并优化
    - 详见：[Empty Base Class Optimisation](https://www.cppstories.com/2021/no-unique-address/)
  - 将`std::unique_ptr`转化为`std::shared_ptr`非常简单

### 19. Use std::shared_ptr for shared-ownership resource management

- `std::shared_ptr`为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。
  - 但是引用计数暗示着性能问题
    - `std::shared_ptr`大小是原始指针的两倍，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针
    - 引用计数的内存必须动态分配，条款21会解释使用`std::make_shared`创建`std::shared_ptr`可以避免引用计数的动态分配，但是还存在一些`std::make_shared`不能使用的场景，这时候引用计数就会动态分配
    - 递增递减引用计数必须是原子性的，因为多个reader、writer可能在不同的线程，原子操作通常比非原子操作要慢，所以即使引用计数通常只有一个word大小，你也应该假定读写它们是存在开销的。
  - 默认资源销毁是通过delete，但是也支持自定义删除器，删除器的类型是什么对于`std::shared_ptr`的类型没有影
    - 这种支持有别于`std::unique_ptr`，对于它来说，删除器类型是智能指针类型的一部分，但是对于`std::shared_ptr`则不是
    - 另一个不同于`std::unique_ptr`的地方是，指定自定义删除器不会改变`std::shared_ptr`对象的大小，不管删除器是什么，对象都是两个指针大小
  - 避免从原始指针变量上创建std::shared_ptr
